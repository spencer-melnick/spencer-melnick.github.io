---
layout:     post
title:      "Weekend Update"
subtitle:   "Much less interesting than SNL, but..."
date:       2015-09-06 22:33:00
author:     "Spencer Melnick"
header-img: "img/blue_bg.jpg"
comments:   true
---

It's been quite an interesting weekend! What with the Temple-PSU upset, and Labor Day vaction and all. Meanwhile, I've been busy coding at home...

I updated [alchemy-game](https://github.com/spencer-melnick/alchemy-game) with the basic architecture for the entity/component system, including a dynamic typing system.

My main goal is to have all entities be a collection of components, as well as nodes in a scene graph. In the finalized code, all systems should simply accept entities as arguments in an update() function, and operate on their relevant components.

For example, for rendering the graphics system would accept the root "scene" entity and traverse the tree for every entity with a "graphics" component and draw it appropriately, pushing the transformation matrix stack at every node. Messages between components can then be simply used to convey state changes, while the actual processing will mostly be handled by the system object.

A lot of my code has implemented the Curiously Recurring Template Pattern and I had no idea that such a construct was even valid C++ syntax until recently. The main usage I've found for CRTP so far is the implementation of utility classes on abstract base classes, to be utilized in derived classes.

Other objects I've been utilizing a lot lately are smart pointers. It's extremely useful to have a lightweight library for smart pointers included in C++11 (I'm not a huge fan of the bloat associated with the Boost library).

Regardless, the main convention that I've been using is that if a function accepts a shared_ptr as a parameter, the ownership of that object is transferred to some other object as defined in the function - this mainly with member functions where the passed shared_ptr data is now owned by the class itself.

In regards with common C++ style conventions ([or at least those defined by Google developers](https://google-styleguide.googlecode.com/svn/trunk/cppguide.html)), most functions will return or accept a weak_ptr when ownership is not transferred.


Despite all of this, there is no game in any sense of the word! Hopefully this architecture will lend itself to easy, extensible development from here on out. After that, I have many choices to make!

I'm tempted to use a lightweight 3D library, such as [bgfx](https://github.com/bkaradzic/bgfx) for rendering in a 2.5D world, or possibly to stick with basic SDL 2D rendering, but both should be easily to implement in the engine.
